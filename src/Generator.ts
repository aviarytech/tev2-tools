import { saf } from "./Run.js";
import { log } from './Report.js';
import { MRG, TuC, Version } from './Interpreter.js';

import fs = require("fs");
import path = require('path');
import yaml = require('js-yaml');

export class Generator {
    public vsntag: string;

    public constructor({ vsntag }: { vsntag: string }) {
        this.vsntag = vsntag;
    }

    public initialize(): void {
        log.info('Initializing generator...');

        // Check if the vsntag exists in the SAF
        if (this.vsntag) {
            const vsn = saf.versions.find(vsn => vsn.vsntag === this.vsntag);
            if (vsn) {
                log.info(`\x1b[1;37mProcessing version '${vsn.vsntag}'...`);
                this.generate(vsn);
            } else {
                // check altvsntags
                const vsn = saf.versions.find(vsn => vsn.altvsntags.includes(this.vsntag));

                if (vsn) {
                    log.info(`\x1b[1;37mProcessing version '${vsn.vsntag}' (altvsn '${this.vsntag}')...`);
                    this.generate(vsn);
                } else {
                    // TODO Run onnotexist? Seems strange to do as there is no other vsntag to process
                    throw new Error(`The specified vsntag '${this.vsntag}' was not found in the SAF`);
                }
            }
        } else {
            // If no vsntag was specified, process all versions
            log.info(`No vsntag was specified. Processing all versions...`);
            if (saf.versions?.length === 0) {
                throw new Error(`No versions were found in the SAF`);
            }
            saf.versions?.forEach(vsn => {
                log.info(`\x1b[1;37mProcessing version '${vsn.vsntag}'...`);
                this.generate(vsn);
            });
        }

        // Handle synonymOf entries if they exist in curated text
        if (TuC.synonymOf.length > 0) {
            log.info(`\x1b[1;37mProcessing synonymOf entries...`);
        }
        let mrgfileWarnings: string[];
        TuC.synonymOf?.forEach((synonymOf, index) => {
            // wrangle the synonymOf field using a regex
            let properties = synonymOf.synonymOf!.match(/(?:(?<term>[a-z0-9_-]+))(?:(?:@(?:(?<scopetag>[a-z0-9_-]+)))?(?::(?<vsntag>[a-z0-9_-]+))?)/);
            if (properties?.groups) {
                let mrgfile = `mrg.${properties.groups.scopetag ?? saf.scope.scopetag}.${properties.groups.vsntag ?? saf.scope.defaultvsn}.yaml`;
                // if the mrgfile exists as a MRG.instance, use that instance. Otherwise, create a new instance
                let mrg = MRG.instances.find(mrg => mrg.filename === mrgfile) ?? new MRG({ filename: mrgfile });

                if (mrg) {
                    // find the corresponding entry in the MRG
                    let entrymatch = mrg.entries.find(entry => entry.term === properties!.groups!.term);
                    if (entrymatch) {
                        // remove fields that are generated by the MRGT
                        Object.keys(synonymOf).forEach(key => {
                            if (['headingids', 'navurl', 'locator', 'scopetag'].includes(key.toLowerCase())) {
                                delete synonymOf[key];
                            }
                        });
                        // merge the synonymOf entry with the MRG entry
                        TuC.synonymOf[index] = { ...entrymatch, ...TuC.synonymOf[index] }
                    } else {
                        // remove the synonymOf entry if it doesn't exist in the MRG
                        TuC.synonymOf.splice(index, 1);
                        log.warn(`\tTerm '${properties!.groups!.term}' not found in MRG '${mrgfile}'`);
                    }
                } else {
                    // remove the synonymOf entry if it doesn't exist in the MRG
                    TuC.synonymOf.splice(index, 1);
                    if (!mrgfileWarnings.includes(mrgfile)) {
                        log.warn(`\tMRG '${mrgfile}' not found`);
                        mrgfileWarnings.push(mrgfile);
                    }
                }
            }
        });

        // Handle synonymOf entries if they exist in TuC.entries
        TuC.instances.filter(i => i.cText)?.forEach(tuc => {
            // find matches in TuC.entries for each TuC.synonymOf
            TuC.synonymOf?.forEach(synonymOf => {
                let index = tuc.entries.findIndex(entry => {
                    // see if every field in entry matches the corresponding field in synonymOf
                    return Object.keys(entry).every(key => {
                        return entry[key] === synonymOf[key];
                    });
                });
                if (index >= 0) {
                    tuc.entries[index] = synonymOf;
                }
            });

            // output the modified tuc.entries array to a file
            writeFile(path.join(saf.scope.localscopedir, saf.scope.glossarydir, tuc.filename), yaml.dump(tuc.output(), { forceQuotes: true }));
        });
    }

    public generate(vsn: Version): void {
        let tuc = new TuC({ vsn: vsn });
        let glossarydir = path.join(saf.scope.localscopedir, saf.scope.glossarydir);

        // Output the MRG to a file
        let mrgFile = `mrg.${tuc.terminology.scopetag}.${tuc.terminology.vsntag}.yaml`;
        writeFile(path.join(glossarydir, mrgFile), yaml.dump(tuc.output(), { forceQuotes: true }));

        // if the version is the default version, create a symbolic link
        if (saf.scope.defaultvsn === tuc.terminology.vsntag) {
            let defaultmrgFile = `mrg.${tuc.terminology.scopetag}.yaml`;
            let defaultmrgURL = path.join(glossarydir, defaultmrgFile);
            log.info(`\tCreating symlink for default version '${vsn.vsntag}'`);
            if (!fs.existsSync(defaultmrgURL)) {
                fs.symlinkSync(mrgFile, defaultmrgURL);
            } else {
                // overwrite existing symlink
                fs.unlinkSync(defaultmrgURL);
                fs.symlinkSync(mrgFile, defaultmrgURL);
            }
        }

        // Create a symlink for every altvsntag
        if (typeof vsn.altvsntags === 'string') {
            vsn.altvsntags = [vsn.altvsntags];
        }
        vsn.altvsntags?.forEach(altvsntag => {
            let altmrgFile = `mrg.${tuc.terminology.scopetag}.${altvsntag}.yaml`;
            let altmrgURL = path.join(glossarydir, altmrgFile);
            log.info(`\tCreating symlink for altvsntag '${altvsntag}'`);
            if (!fs.existsSync(altmrgURL)) {
                fs.symlinkSync(mrgFile, altmrgURL);
            } else {
                // overwrite existing symlink
                fs.unlinkSync(altmrgURL);
                fs.symlinkSync(mrgFile, altmrgURL);
            }
        });
    }
}

/**
 * Creates directory tree and writes data to a file.
 * @param fullPath - The full file path.
 * @param data - The data to write.
 * @param force - Whether to overwrite existing files.
 */
export function writeFile(fullPath: string, data: string, force: boolean = true) {
    const dirPath = path.dirname(fullPath);
    const file = path.basename(fullPath);
    // Check if the directory path doesn't exist
    if (!fs.existsSync(dirPath)) {
        // Create the directory and any necessary parent directories recursively
        try {
            fs.mkdirSync(dirPath, { recursive: true });
        } catch (err) {
            log.error(`\tE007 Error creating directory '${dirPath}':`, err);
            return; // Stop further execution if directory creation failed
        }
    } else if (!force && fs.existsSync(path.join(dirPath, file))) {
        return; // Stop further execution if force is not enabled and file exists
    }

    try {
        fs.writeFileSync(path.join(dirPath, file), data);
    } catch (err) {
        log.error(`\tE008 Error writing file '${path.join(dirPath, file)}':`, err);
    }
}
