import { saf } from "./Run.js"
import { log } from "./Report.js"
import { Entry, MRG, TuC, Version } from "./Interpreter.js"
import { writeFile } from "./Handler.js"

import path = require("path")
import yaml = require("js-yaml")

export class Generator {
  public vsntag: string

  public constructor({ vsntag }: { vsntag: string }) {
    this.vsntag = vsntag
  }

  public initialize(): void {
    log.info("Initializing generator...")

    // Check if the vsntag exists in the SAF
    if (this.vsntag) {
      const vsn = saf.versions?.find((vsn) => vsn.vsntag === this.vsntag)
      if (vsn) {
        log.info(`\x1b[1;37mProcessing version '${vsn.vsntag}' (mrg.${saf.scope.scopetag}.${vsn.vsntag}.yaml)...`)
        this.generate(vsn)
      } else {
        // check altvsntags
        const vsn = saf.versions?.find((vsn) => vsn.altvsntags.includes(this.vsntag))

        if (vsn) {
          log.info(
            `\x1b[1;37mProcessing version '${vsn.vsntag}' (altvsn '${this.vsntag}') (mrg.${saf.scope.scopetag}.${vsn.vsntag}.yaml)...`
          )
          this.generate(vsn)
        } else {
          // TODO Run onnotexist? Seems strange to do as there is no other vsntag to process
          throw new Error(`The specified vsntag '${this.vsntag}' was not found in the SAF`)
        }
      }
    } else {
      // If no vsntag was specified, process all versions
      log.info(`No vsntag was specified. Processing all versions...`)
      if (saf.versions?.length === 0) {
        throw new Error(`No versions were found in the SAF`)
      }
      saf.versions?.forEach((vsn) => {
        log.info(`\x1b[1;37mProcessing version '${vsn.vsntag}' (mrg.${saf.scope.scopetag}.${vsn.vsntag}.yaml)...`)
        this.generate(vsn)
      })
    }

    // Handle synonymOf entries if they exist in curated text
    if (TuC.synonymOf.length > 0) {
      log.info(`\x1b[1;37mProcessing synonymOf entries...`)
    }
    let mrgfileWarnings: string[]
    TuC.synonymOf?.forEach((synonymOf, index) => {
      // wrangle the synonymOf field using a regex
      const properties = synonymOf.synonymOf!.match(
        /(?:(?<term>[a-z0-9_-]+))(?:(?:(?<identifier>@)(?:(?<scopetag>[a-z0-9_-]+)?))?(?::(?<vsntag>.+))?)/
      )
      if (properties?.groups) {
        let entrymatch: Entry | undefined
        // if no identifier (@) is specified, refer to the ctextmap
        if (!properties.groups.identifier) {
          entrymatch = TuC.cTextMap?.find((ctext) => ctext.term === properties!.groups!.term)
          // if the identifier is @, refer to the MRG
        } else {
          const mrgfile = `mrg.${properties.groups.scopetag ?? saf.scope.scopetag}.${
            properties.groups.vsntag ?? saf.scope.defaultvsn
          }.yaml`
          // if the mrgfile exists as a MRG.instance, use that instance. Otherwise, create a new instance
          const mrg = MRG.instances?.find((mrg) => mrg.filename === mrgfile) ?? new MRG({ filename: mrgfile })
          if (mrg) {
            entrymatch = mrg.entries?.find((entry) => entry.term === properties!.groups!.term)
            if (!entrymatch) {
              // remove the synonymOf entry if it doesn't exist in the MRG
              TuC.synonymOf.splice(index, 1)
              log.warn(`\tTerm '${properties!.groups!.term}' not found in MRG '${mrgfile}'`)
            }
          } else {
            // remove the synonymOf entry if the MRG cannot be found
            TuC.synonymOf.splice(index, 1)
            if (!mrgfileWarnings.includes(mrgfile)) {
              log.warn(`\tMRG '${mrgfile}' not found`)
              mrgfileWarnings.push(mrgfile)
            }
          }
        }

        if (entrymatch) {
          // remove fields that are generated by the MRGT
          Object.keys(synonymOf).forEach((key) => {
            if (["headingids", "navurl", "locator", "scopetag"].includes(key.toLowerCase())) {
              delete synonymOf[key]
            }
          })
          // merge the synonymOf entry with the MRG entry
          TuC.synonymOf[index] = { ...entrymatch, ...TuC.synonymOf[index] }
        }
      }
    })

    // Handle TuC.synonymOf entries if they exist in TuC.entries
    TuC.instances
      .filter((i) => i.cText)
      ?.forEach((tuc) => {
        // find matches in TuC.entries for each TuC.synonymOf
        TuC.synonymOf?.forEach((synonymOf) => {
          const index = tuc.entries?.findIndex((entry) => {
            // see if every field in entry matches the corresponding field in synonymOf
            return Object.keys(entry).every((key) => {
              return entry[key] === synonymOf[key]
            })
          })
          if (index >= 0) {
            tuc.entries[index] = synonymOf
          }
        })

        // output the modified tuc.entries array to a file
        writeFile(
          path.join(saf.scope.localscopedir, saf.scope.glossarydir, tuc.filename),
          yaml.dump(tuc.output(), { forceQuotes: true })
        )
      })
  }

  public generate(vsn: Version): void {
    const tuc = new TuC({ vsn: vsn })
    const glossarydir = path.join(saf.scope.localscopedir, saf.scope.glossarydir)

    // Output the MRG to a file
    const mrgFile = `mrg.${tuc.terminology.scopetag}.${tuc.terminology.vsntag}.yaml`
    writeFile(path.join(glossarydir, mrgFile), yaml.dump(tuc.output(), { forceQuotes: true }))

    if (vsn.altvsntags || saf.scope.defaultvsn === tuc.terminology.vsntag) {
      log.info(`\tCreating duplicates...`)
    }

    // if the version is the default version, create a duplicate {mrg.{import-scopetag}.yaml}
    if (saf.scope.defaultvsn === tuc.terminology.vsntag || tuc.terminology.altvsntags?.includes(saf.scope.defaultvsn)) {
      const defaultmrgURL = path.join(glossarydir, `mrg.${tuc.terminology.scopetag}.yaml`)
      writeFile(defaultmrgURL, yaml.dump(mrgFile, { forceQuotes: true }))
      log.trace(`\t\t'${path.basename(defaultmrgURL)}' (default) > '${mrgFile}'`)
    }

    // Create a duplicate for every altvsntag
    if (typeof vsn.altvsntags === "string") {
      vsn.altvsntags = [vsn.altvsntags]
    }
    vsn.altvsntags?.forEach((altvsntag) => {
      const altmrgURL = path.join(glossarydir, `mrg.${tuc.terminology.scopetag}.${altvsntag}.yaml`)
      writeFile(altmrgURL, yaml.dump(mrgFile, { forceQuotes: true }))
      log.trace(`\t\t'${path.basename(altmrgURL)}' (altvsn)`)
    })
  }
}
